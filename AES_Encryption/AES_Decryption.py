from array import*
import numpy as np
import string

#####******    AES Decryption Algorithm ******##########
'''
AES Decryption Algorithm
Remember the key expansion uses the same S_box, not the InvS_box; I made this mistake, => This costed me
a lot of time, suck!!!!!!!!!!!!!! 
byte state[4,Nb]

state = in

AddRoundKey(state, keySchedule[Nr*Nb, (Nr+1)*Nb-1])

for round = Nr-1 step -1 downto 1 {
	InvShiftRows(state) 
	InvSubBytes(state)
	AddRoundKey(state, keySchedule[round*Nb, (round+1)*Nb-1])
	InvMixColumns(state)
}

InvShiftRows(state)
InvSubBytes(state)
AddRoundKey(state, keySchedule[0, Nb-1])

out = state

'''

#Global variables:
##########
InvS_box = bytearray([0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,
    0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,
    0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,
    0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,
    0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,
    0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,
    0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,
    0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,
    0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,
    0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,
    0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,
    0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,
    0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,
    0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D, 0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,
    0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0, 0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,
    0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26, 0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D])
##########
S_box = bytearray([0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16])

#########
mul9 = bytearray([0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46])
########
mul11 = bytearray([0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3])
########
mul13 = bytearray([0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97])
########
mul14 = bytearray([0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d])
#########
RCon = ([0x01, 0x00, 0x00, 0x00],[0x02, 0x00, 0x00, 0x00],[0x04, 0x00, 0x00, 0x00],[0x08, 0x00, 0x00, 0x00],
        [0x10, 0x00, 0x00, 0x00],[0x20, 0x00, 0x00, 0x00],[0x40, 0x00, 0x00, 0x00],[0x80, 0x00, 0x00, 0x00],
        [0x1b, 0x00, 0x00, 0x00],[0x36, 0x00, 0x00, 0x00])
####################

# Functions
        
def shiftBB(key,arrayK): #This is shift right
    rollBB=np.roll(arrayK,key)
    return rollBB
###########
def shift_Left(key,arrayK): #This is shift Left
    rollBB=np.roll(arrayK,-key)
    return rollBB
##########
def shift_Right(key,arrayK): #This is shift right for the Inverse
    rollBB=np.roll(arrayK,key)
    return rollBB
##########
def KeyExpand1(RCon_round, TempkeyRound):
    #shilf lelf
    key_temp1 = shiftBB(-1,TempkeyRound)
    #this is S-box step
    for i in range(4):
        key_temp1[i]= S_box[key_temp1[i]] #should I convert this value to hex or just leave that way?
       
    #Adding round constant
    t=RCon[RCon_round]   
    for i in range (4):
        key_temp1[i]= key_temp1[i]^t[i]
    return key_temp1
#########
def KeyExpansion(keyin): #(keyin is initial key, an array 2d in hex value), 
    K_Expansion =  np.zeros([44, 4], np.integer) #initialize an 2d array to contain 11 key, each key 4 bytes
    #copy the keyin into the K_Expansion
    for i in range(4):
        for j in range(4):
            K_Expansion [i][j]= int(keyin[i][j],16)

    Rcon_iter = 0 #iter is the number byte of RCON
    NumByte=0 #initialize the number of byte (44 bytes)
    #done with the first 4x4 bytes of key, this one is for the first round

    while (NumByte<40):
        temp1 = K_Expansion[NumByte+3] #this to convert 2d to 1d array 
        key_temp1=KeyExpand1(Rcon_iter, temp1)
        
        ##XOR with the first array of keyin
        temp4 =K_Expansion[NumByte] #convert to 1d array  
        kt0 = ([0x00, 0x00, 0x00, 0x00])
        for i in range (4):
            kt0[i] = key_temp1[i]^temp4[i]
        #Got the 4th 4bytes of the key
        K_Expansion[NumByte+4] = kt0 
        
        #do the 5th, 6th, 7th byte
        NumByte =NumByte+1 #=1
        for i in range (3):
            kt1 = ([0x00, 0x00, 0x00, 0x00])
            kt2 = K_Expansion[NumByte]  
            kt3 = K_Expansion[NumByte+3]  
            for j in range (4):
                kt1[j] = kt2[j]^kt3[j]
            K_Expansion[NumByte+4] = kt1  
            NumByte +=1 
       
        Rcon_iter +=1    
    #Finished getting 44 bytes
    #now convert 2d array to 1d then group 4 bytes into one 1d array
     
    #Split 44 byte into 4 byte, 4-byte makes a key for one round
    K_Expansion = np.vsplit(K_Expansion, 11) 
    #switch row to column
    for i in range(len(K_Expansion)):
        K_Expansion[i] = K_Expansion[i].T 
        
    return K_Expansion

##########

def InvSubBytes(state_in):
    for i in range (len(state_in)):
        for j in range (len(state_in[i])):
            state_in[i][j] = InvS_box[state_in[i][j]]   
    return state_in
###################
def InvShiftRows(state_shift):   
    arraytemp2 =[] #this is for the row to do the shifting
    for i in range(4):
        arraytemp2 = state_shift[i]
        if (i==0): 
            state_shift[i] = arraytemp2
        else: 
            state_shift[i] = shift_Right(i,arraytemp2)
    return state_shift
###############
def InvMixColumns(state_Mix):
    '''
    this step is the most complicated one

    Each column is treated as a polynomial over GF(28) 
    and is then multiplied modulo {\displaystyle x^{4}+1} x^{4}+1 
    with a fixed polynomial {\displaystyle c(x)=3x^{3}+x^{2}+x+2} c(x)=3x^{3}+x^{2}+x+2;
    the inverse of this polynomial is {\displaystyle c^{-1}(x)=11x^{3}+13x^{2}+9x+14} c^{{-1}}(x)=11x^{3}+13x^{2}+9x+14
    
    '''
    #MixCol = [[2,3,1,1],[1,2,3,1],[1,1,2,3],[3,1,1,2]] #copy this array from https://en.wikipedia.org/wiki/Rijndael_mix_columns
    MixCol = [[14,11,13,9],[9,14,11,13],[13,9,14,11],[11,13,9,14]]
    Temp_Mix  = np.zeros([4, 4], np.integer)  # initialize 2D array with value '0'
    #Temp_Mix  = ([0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0])
    
    for i in range (4): #i is the row of the array MixCol
        temp_store = [0,0,0,0] #temporary value
        for j in range (4): #j is the number column of state
            for k in range (4):# k is the number rows of state
                #For the multiplication of two arrays, use Galois Multiplication lookup tables
                if (MixCol[i][k]==9): temp_store[k] =mul9[state_Mix[k][j]]
                elif (MixCol[i][k]==11): temp_store[k] =mul11[state_Mix[k][j]]
                elif (MixCol[i][k]==13): temp_store[k] =mul13[state_Mix[k][j]]
                elif (MixCol[i][k]==14): temp_store[k] =mul14[state_Mix[k][j]]
                
                  
            Temp_Mix[i][j]= temp_store[0]^temp_store[1]^temp_store[2]^temp_store[3]
                     
    return Temp_Mix
#############
def AddRoundKey(state, roundKey): #roundkey is an array
    
    for i in range (len(state)):
        for j in range (len(state[i])):
            state[i][j] ^= roundKey[i][j]
    return state

#########################################################
#########################################################

def AES_Decrypt(EncryptM, KeyEx_in):
    #En_list = []
    #for c in state:
       # state_list.append(ord(c)) #this one just take the integer value of character
    En_text2d = [[i for i in range(4)] for j in range(4)] #initialize 2d array to contain value of the message (state)
    for i in range (4):
        En_text2d[i] = EncryptM[i*4:(i+1)*4]
    #convert hex string to hex value
    
    for ii in range (len(En_text2d)):
        for jj in range (len(En_text2d[ii])):
            En_text2d[ii][jj] = int(En_text2d[ii][jj],16)
         
    #state =>convert to array in order to switch row to column
    state= np.array(En_text2d)
    state = state.T   
    Num_Round =9
    Key10 = KeyEx_in[10]
    state = AddRoundKey(state, Key10) 
    for i in range (Num_Round):
        state = InvShiftRows(state)
       
        state = InvSubBytes(state) #wrong right this step after the first round ? 
        RoundKeyTemp = KeyEx_in[9-i]
        
        state = AddRoundKey(state,RoundKeyTemp)  
              
        state = InvMixColumns(state)        
        
    # This is the final round
    state = InvShiftRows(state)
    state = InvSubBytes(state)
    state = AddRoundKey(state,KeyEx_in[0]) 

    ####################
    state = state.T
    #encrypt_Text = state.T #This is the final result

   
    E_text1 = [[i for i in range(4)] for j in range(4)]
   # E_text3 = [[i for i in range(4)] for j in range(4)]
    for i in range(len(state)):
        for j in range(len(state[i])):            
            E_text1[i][j] = chr(state[i][j])
          
             
    En_text1= ''.join(''.join(n for n in ar) for ar in E_text1)+' ' 

    return En_text1


## -----------------Main program--------------------####

print "*****************************************************************\n"
print "----------FAU - COT5930 - Applied Cryptography Fall2016----------\n"
print "-------------------------AES DECRYPTION--------------------------\n"
print "--------------------Deepthi ** Khoa ** Patorn--------------------\n"
print "******************************************************************\n\n"
##### Website to check
# http://aes.online-domain-tools.com/
##### Collecting data - those are Message to send and Key to encrypt enter from the user

#Ask input the key to do the decryption
while True:
    key_input = raw_input ("Please enter the key (16 characters = 128 bits) for the AES Decryption: ")
    if (len(key_input)) <>16:
        print "The key should 16 characters - 16 ASCII\n"   
        continue
    else:
        
        break
print "************************************** \n"
print "This is the key you have entered:      " + key_input +"\n"
array_key = []
for c in key_input:
    array_key.append('{:02x}'.format(ord(c)))

key2d = [[i for i in range(4)] for j in range(4)] #initialize 2d array to contain hex key value
for i in range (0,4):
    key2d[i] = array_key[i*4:(i+1)*4]

#Now key2d is the original key in 2d array hex value, it has 16 bytes (4 row and 4 columns)
#Do the expanded key from 16 bytes to 176 bytes
KeyExpended = KeyExpansion(key2d)

#Ask input encrypted text to do the decryption

while True:
    en_text = raw_input ("Please enter the encrypted message: ")
    ListEn=en_text.split()
    
    if (len(ListEn)%16 <>0):
        print "The encrypted message must be 16x hexadecimal characters\n"   
        continue
    elif (all(c in string.hexdigits for c in en_text.replace(" ",""))==False):
        print "Encrypted text must be hexadecimal \n"
    else:
        
        break
print "************************************** \n"
print "This is the message that you want to encrypt:      " + en_text +"\n"

nBlock = len(ListEn)/16

Block_TextIn = [[0 for x in range(16)] for y in range(nBlock)]
for k in range (nBlock):
    Block_TextIn[k] = ListEn[k*16:(k+1)*16]

#############################
# Finish collecting data
############################
#Now call the AES Decryption
DecipherText =[]
for ii in range (nBlock):
    result_AES1 =AES_Decrypt(Block_TextIn[ii], KeyExpended)
    DecipherText.append(result_AES1)
print "This is the decipher text"
print  ''.join(n for n in DecipherText) + "\n"

####Done########