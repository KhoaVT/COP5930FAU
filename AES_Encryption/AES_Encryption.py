from array import*
import numpy as np
import string
#AES Encryption Algorithm
'''
AES Encryption Algorithm

1. Key Expansion
2. Initial Round:
    AddRoundKey
    (The message comes in at this step)
3. Rounds:
    SubBytes
    ShiftRows
    MixColumns
    AddRoundKey
4. Final Round:
    SubBytes
    ShiftRows
    AddRoundKey
'''

#Global variables:
##########
S_box = bytearray([0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,
    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,
    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,
    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,
    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,
    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,
    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,
    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,
    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,
    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,
    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,
    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,
    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,
    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,
    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,
    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16])

#########
mul2 = bytearray([0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5])

#########
mul3 = bytearray([0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a])
########
'''
Rcon = ([0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d])
'''
#########
RCon = ([0x01, 0x00, 0x00, 0x00],[0x02, 0x00, 0x00, 0x00],[0x04, 0x00, 0x00, 0x00],[0x08, 0x00, 0x00, 0x00],
        [0x10, 0x00, 0x00, 0x00],[0x20, 0x00, 0x00, 0x00],[0x40, 0x00, 0x00, 0x00],[0x80, 0x00, 0x00, 0x00],
        [0x1b, 0x00, 0x00, 0x00],[0x36, 0x00, 0x00, 0x00])
####################


# Functions

def convert(str, chunk_size):
    for i in xrange(0, len(str), chunk_size):
        yield str[i:i+chunk_size]

def shiftBB(key,arrayK): #This is shift right
    rollBB=np.roll(arrayK,key)
    return rollBB
###########
def shift_Left(key,arrayK): #This is shift Left
    rollBB=np.roll(arrayK,-key)
    return rollBB
##########
def KeyExpand1(RCon_round, TempkeyRound):
    #shilf lelf
    key_temp1 = shiftBB(-1,TempkeyRound)
   
    #this is S-box step
    for i in range(4):
        key_temp1[i]= S_box[key_temp1[i]] #should I convert this value to hex or just leave that way?
       
    #Adding round constant
    t=RCon[RCon_round]   
    for i in range (4):
        key_temp1[i]= key_temp1[i]^t[i]
    return key_temp1
#########
def KeyExpansion(keyin): #(keyin is initial key, an array 2d in hex value), 
    K_Expansion =  np.zeros([44, 4], np.integer) #initialize an 2d array to contain 11 key, each key 4 bytes
    #copy the keyin into the K_Expansion
    for i in range(4):
        for j in range(4):
            K_Expansion [i][j]= int(keyin[i][j],16)

    Rcon_iter = 0 #iter is the number byte of RCON
    NumByte=0 #initialize the number of byte (44 bytes)

    while (NumByte<40):
        temp1 = K_Expansion[NumByte+3] #this to convert 2d to 1d array 
        key_temp1=KeyExpand1(Rcon_iter, temp1)
        
        ##XOR with the first array of keyin
        temp4 =K_Expansion[NumByte] #convert to 1d array  
        kt0 = ([0x00, 0x00, 0x00, 0x00])
        for i in range (4):
            kt0[i] = key_temp1[i]^temp4[i]

        K_Expansion[NumByte+4] = kt0 
        #do the 5th, 6th, 7th byte
        NumByte =NumByte+1 #=1
        for i in range (3):
            kt1 = ([0x00, 0x00, 0x00, 0x00])
            kt2 = K_Expansion[NumByte]  
            kt3 = K_Expansion[NumByte+3]  
            for j in range (4):
                kt1[j] = kt2[j]^kt3[j]
            K_Expansion[NumByte+4] = kt1  
            NumByte +=1 
  
        Rcon_iter +=1    
    #Finished getting 44 bytes
    #now convert 2d array to 1d then group 4 bytes into one 1d array
    #Split 44 byte into 4 byte, 4-byte makes a key for one round
    K_Expansion = np.vsplit(K_Expansion, 11) 
    #switch row to column
    for i in range(len(K_Expansion)):
        K_Expansion[i] = K_Expansion[i].T         
    return K_Expansion
############
def SubBytes(state_in):
    for i in range (len(state_in)):
        for j in range (len(state_in[i])):
            state_in[i][j] = S_box[state_in[i][j]]   
    return state_in
###################
def ShiftRows(state_shift):   
    arraytemp2 =[] #this is for the row to do the shifting
    for i in range(4):
        arraytemp2 = state_shift[i]
        if (i==0): 
            state_shift[i] = arraytemp2
        else: 
            state_shift[i] = shift_Left(i,arraytemp2)
    return state_shift
###############
def MixColumns(state_Mix):
    '''
    this step is the most complicated one

    Each column is treated as a polynomial over GF(28) 
    and is then multiplied modulo {\displaystyle x^{4}+1} x^{4}+1 
    with a fixed polynomial {\displaystyle c(x)=3x^{3}+x^{2}+x+2} c(x)=3x^{3}+x^{2}+x+2;
    the inverse of this polynomial is {\displaystyle c^{-1}(x)=11x^{3}+13x^{2}+9x+14} c^{{-1}}(x)=11x^{3}+13x^{2}+9x+14
    
    '''
    MixCol = [[2,3,1,1],[1,2,3,1],[1,1,2,3],[3,1,1,2]] #copy this array from https://en.wikipedia.org/wiki/Rijndael_mix_columns
    
    Temp_Mix  = np.zeros([4, 4], np.integer)  # initialize 2D array with value '0'
    #Temp_Mix  = ([0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0])

    for i in range (4): #i is the row of the array MixCol
        temp_store = [0,0,0,0] #temporary value
        for j in range (4): #j is the number column of state
            for k in range (4):# k is the number rows of state
                #For the multiplication of two arrays, use Galois Multiplication lookup tables
                if (MixCol[i][k]==3): temp_store[k] =mul3[state_Mix[k][j]]
                elif (MixCol[i][k]==2): temp_store[k] =mul2[state_Mix[k][j]]
                else: temp_store[k] = state_Mix[k][j]
                  
            Temp_Mix[i][j]= temp_store[0]^temp_store[1]^temp_store[2]^temp_store[3]           
    return Temp_Mix
#############
def AddRoundKey(state, roundKey): #roundkey is an array    
    for i in range (len(state)):
        for j in range (len(state[i])):
            state[i][j] ^= roundKey[i][j]
    return state

#########################################################

def AES_Encrypt(state, KeyEx_in):
    state_list = []
    for c in state:
        state_list.append(ord(c)) #this one just take the integer value of character
    state2d = [[i for i in range(4)] for j in range(4)] #initialize 2d array to contain value of the message (state)
    for i in range (4):
        state2d[i] = state_list[i*4:(i+1)*4]
    
    #state =>convert to array in order to switch row to column
    state= np.array(state2d)
    state = state.T
##############
    Num_Round =9
    Key0 = KeyEx_in[0]
    state = AddRoundKey(state, Key0) #Rkey is an array
    for i in range (Num_Round):
        state = SubBytes(state)

        state = ShiftRows(state)

        state = MixColumns(state) 

        RoundKeyTemp = KeyEx_in[i+1]
        state = AddRoundKey(state,RoundKeyTemp)

    # This is the final round
    state = SubBytes(state)

    state = ShiftRows(state)
    
    state = AddRoundKey(state,KeyEx_in[10]) 

    ####################

    encrypt_Text = state.T #This is the final result
        
    E_text1 = [[0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0],
              [0x0,0x0,0x0,0x0],[0x0,0x0,0x0,0x0]]
    E_text2 = [[i for i in range(4)] for j in range(4)]
   # E_text3 = [[i for i in range(4)] for j in range(4)]
    for i in range(len(encrypt_Text)):
        for j in range(len(encrypt_Text[i])):            
            E_text1[i][j] = hex(encrypt_Text[i][j]).rstrip("L")
            #E_text2[i][j] = hex(encrypt_Text[i][j]).rstrip("L").lstrip("0x")
            E_text2[i][j] =  '{:02X}'.format(encrypt_Text[i][j])
             
    En_text1= ' '.join(' '.join(n for n in ar) for ar in E_text1)+' ' 
    En_text2= ' '.join(' '.join(n for n in ar) for ar in E_text2) +' '
   
    return En_text1, En_text2


## -----------------Main program--------------------####

print "*****************************************************************\n"
print "----------FAU - COT5930 - Applied Cryptography Fall2016----------\n"
print "-------------------------AES ENCRYPTION--------------------------\n"
print "--------------------Deepthi ** Khoa ** Patorn--------------------\n"
print "******************************************************************\n\n"

##### Website to check
# http://aes.online-domain-tools.com/
##### Collecting data - those are Message to send and Key to encrypt enter from the user

#Ask input the key to do the encryption
while True:
    key_input = raw_input ("Please enter the key (16 characters = 128 bits) for the AES encryption: ")
    if (len(key_input)) <>16:
        print "The key should 16 characters - 16 ASCII\n"   
        continue
    else:
        
        break
print "************************************** \n"
print "This is the key you have entered:      " + key_input +"\n"
array_key = []
for c in key_input:
    array_key.append('{:02x}'.format(ord(c)))

key2d = [[i for i in range(4)] for j in range(4)] #initialize 2d array to contain hex key value
for i in range (0,4):
    key2d[i] = array_key[i*4:(i+1)*4]

#Now key2d is the original key in 2d array hex value, it has 16 bytes (4 row and 4 columns)
#Do the expanded key from 16 bytes to 176 bytes
KeyExpended = KeyExpansion(key2d)

#Ask input message to do the encryption

while True:
    ptext = raw_input ("Please enter the plain text (16x characters) to encrypt: ")
    if (len(ptext)%16 <>0):
        print "Plain text must be 16x characters - 16 ASCII\n"   
        continue
    else:
        
        break
print "************************************** \n"
print "This is the message that you want to encrypt:      " + ptext +"\n"

#ptext ='Khoa Dang Hoang1'
nBlock = len(ptext)/16
EncyptionText=[]
Result2=[]
Result3=[]
Block_TextIn = [[0 for x in range(16)] for y in range(nBlock)]
for k in range (nBlock):
    Block_TextIn[k] = ptext[k*16:(k+1)*16]
#############################
# Finish collecting data
############################
#Now call the program AES encryption
for ii in range(nBlock):    
    result_AES1,result_AES2=AES_Encrypt(Block_TextIn[ii], KeyExpended)
    EncyptionText.append(result_AES1)
    Result2.append(result_AES2)
   
  
#print "Here is the encrypted text \n"
#print ''.join(n for n in EncyptionText) + "\n"
print "**************************************"
print "Here is the encrypted text in short form \n"
print  ''.join(n for n in Result2) + "\n"

############### Done######################
